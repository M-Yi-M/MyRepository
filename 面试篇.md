# MySql篇	

## 一.MySql索引

### 	1.概述：

​		索引是一种数据结构，为了加快查询速度而设置；

一般而言底层使用的数据结构是B+树 :why-

![image-20240910190357548](imgs/image-20240910190357548.png)

​	1.采用树这种结构：主要因为在树结构下便于查询和更新数据

​	2.采用B+树这种结构：

​		a.加快查询速率(减少磁盘IO)：B+树是一种平衡树，树的高度会通过平衡机制保持在一定高度(平衡性)，这就使得其IO次数不大

​		b.B+树：非叶子节点存储索引列，叶子节点才存储实际数据；这样设计一可以**减少索引时的数据开销**二是在叶子节点的实际数据通过链表按序链接，可以使得**范围查询更加高效和排序操作**

### 	2.索引分类

#### 	按照数据结构分为：

- B+索引
- Hash索引

#### 	按照索引级别分为：

- **聚簇索引**
- 非聚簇索引(二级索引)

#### 	按照功能分类：

- 主键索引
- 普通索引
- 唯一索引
- 全文索引

#### 	按照索引列数量分：

- 单列索引
- 联合索引

### 	3.索引详情

#### 一、主键索引（聚簇索引）

在Innodb存储引擎中可以这么认为(而在Myisam中不一定)

​	对于主键索引而言，其存储了全部的表中数据(在叶子节点)。这意味着，当通过主键索引查询数据时，可以直接找到包含所有字段的数据记录。因此，在这种情况下，其他字段的信息会被一起加载出来。

聚簇索引中的字段信息

1. **主键字段**：作为聚簇索引的索引键，主键字段的值是必须存储在聚簇索引中的。
2. **其他字段**：除了主键字段外，聚簇索引的叶子节点还包含了与该主键值相对应的数据行的其他所有字段信息。这是因为InnoDB将数据行与聚簇索引的叶子节点紧密结合在一起，实现了数据行与索引键的一体化存储。

#### 二、非主键索引（辅助索引/二级索引）

​	对于非主键索引（也称为辅助索引或二级索引），B+树的叶子节点存储的是索引字段的值和对应的主键字段的值。当通过非主键索引查询数据时，首先会在叶子节点中找到索引字段的值对应的主键，然后再通过主键去聚簇索引中查找完整的数据记录。因此，在这种情况下，其他字段的信息不是直接通过非主键索引加载出来的，而是需要通过额外的步骤（即**回表操作**）去聚簇索引中获取。

#### 三.联合索引(复合索引、组合索引）

​	基于多个列的搜索，可以加快基于多个列的查询速度。每个列的顺序都很重要，查询时会遵守最左匹配原则。

​	在联合索引中，B树的每个节点不仅包含单个键值，而是包含了多个列的键值组合。这些键值组合按照某些规则在B+树的节点上进行排序组合，在叶子点上是完整的键值组合以及其对应的数据

当使用联合索引进行匹配时，会根据键值组合其对联合索引构建的B+树进行索引匹配

最左匹配原则：查询条件中必须包含联合索引的最左侧列（或最左侧列的组合），索引才会被使用



#### 四.全文索引

​	是一种允许用户通过关键词快速检索文档中相关信息的技术

​	全文索引通常应用于需要快速查找和匹配大量文本数据的场景，如内容管理系统、电子文档存储、搜索引擎等。

工作原理：

​	1.**分词：**将预处理后的文本数据切割成一个个独立的词或词组，称为“分词”。

​	2.**建立倒排索引**：倒排索引是一种数据结构-记录了每个单词在文档集合中出现的位置信息

​	文档：在面向文档的数据库中在通常指的是一个由键值对（key-value pairs）或字段（fields）组成的结构化数据集合，这些数据集合被视作一个独立的记录或实体。

​	在面向文档的数据库中，数据通常通过文档ID进行访问，而查询则基于文档的结构和内容。

​	在关系型数据库中：“文档”理解为一种包含多个字段（或属性）的数据记录，并且这些数据记录被存储在关系型数据库的表，

​	3.**查询处理：**全文索引系统会根据查询条件到倒排索引中进行查询并返回满足条件的文档列表，在获取文档集合后通过查询文档所在地来获取数据真正所在地；

​	

### 4.实例

#### 	1.主键索引：

​		SELECT id,username,phone FROM sys_user where id="1246347518934126592"

其中id为主键，那么在进行该段sql语句时就是走的主键索引查询会查询出所有的字段信息

#### 	2.非主键索引：

SELECT id,username,phone FROM sys_user where username="admin"

其中id为主键，username为普通索引，那么这就是非主键索引

一开始走非主键索引查询数据，找到索引字段username对象的主键id值

然后走主键索引(**回表操作**)

SELECT username from sys_user where username ="admin"

这么一个sql：当仅仅查询username时在非主键索引的B+ Tree中就已经有了username的信息故不需要再走主键索引；那么称这种索引方法为：**索引覆盖扫描**

#### 3.联合查询![image-20241223140834318](imgs/image-20241223140834318.png)

在这个表的索引设计中，有两个索引分别是cur_time,stock_code

当我设计该索引时，系统会根据某些规则创建联合索引键值(cur_time,stock_code)对下的B+树，而在查询

SELECT * FROM stock_rt_info where cur_time ='2021-12-30 09:32:00' and `stock_code`='600004';根据的是键值组合:

是(2021-12-30 09:32:00,600004)到数据结构中进行查询

![image-20241223142013202](imgs/image-20241223142013202.png)



## 二.Mysql事务

### 	2.1概述

​		事务：即一系列对数据库的操作 ，且这些操作具有原子性

### 	2.2工作流程

​		![image-20240808134338934](imgs/image-20240808134338934.png)

​	只有当服务端收到事务处理指令后才会将结果同步，当事务中执行发生异常则会rollback全的操作

### 	2.3特性

​	**4个属性**：ACID-原子性(atomicity)；一致性(consistency);隔离性(isolation);持久性(durability)

​	**原子性**：每一个事务都是最小单位操作，事务要么全成功要么全失败

​	**一致性**：事务操作前后，数据总量不变-数据库状态保持不变

​		这意味着事务必须遵守所有由数据库完整性约束（如主键、外键、检查约束等）定义的规则。

还有锁机制来实现事务的一致性

​	**隔离性**：每一个事务都是独立的，每一个用户并行的访问数据库，一个事务内部的操作对其他并发的事务是不可见的直到事务提交，为此设置了不同的隔离级别

​	**持久性**：当事务提交后，数据库会保存数据

### 	2.4安全问题（隔离级别）

由于事务的并发访问和事务之间的交互引发的三个问题

##### 1.问题

​	1.脏读：一个事务读取到了另一个事务中尚未提交的数据

​	2.不可重复读：一个事务中多次读取到数据是不一致的(Update引发的问题)

​	3.幻读(虚读)：一个事务内读取到了另一个数据插入或删除的数据导致前后读取记录行数不同(Insert或Delete引发的问题);

##### 2.隔离级别

​	**READ UNCOMMITTED（读未提交）**：最低的隔离级别-允许事务读取尚未提交的数据：三个问题都有可能产生

​	**READ COMMITTED（读已提交）**：允许事务读取其他事务已经提交的数据，避免了脏读

​	**REPEATABLE READ（可重复读）**：MySQL InnoDB存储引擎的默认隔离级别。它确保在同一事务内多次读取同一数据的结果是一致的，但可能仍然出现幻读

​	**SERIALIZABLE（可串行化）**：最高的隔离级别，事务被串行化执行（完全隔离执行，事务之间无法进行交互），完全避免了脏读、不可重复读和幻读，但会显著降低并发性能

不同的隔离级别由不同的锁机制实现

## 三.Mysql锁/锁机制

### 	3.1概述

​		锁机制是数据库管理系统用于控制对共享资源的访问，避免多个事务同时修改同一数据造成的数据不一致问题。	

一旦一个事务对某个资源加锁后那么该资源对于其他事务而言就存在了对该资源的访问控制；

​	访问控制有读和写的权限

例如事务A对资源R加了共享锁后该资源对于事务B而言就只能读而不能修改

### 	3.2分类

#### 	**按锁的粒度分类**

- **行锁**：锁定表中的某一行或多行记录。其他事务不能修改被锁定的行，但可以同时读取或修改其他行。行锁粒度较小，并发度高，但加锁开销较大。行锁通常基于索引实现，只有在使用索引条件检索数据时，MySQL才会使用行级锁。
- **表锁**：锁定整张表，阻止其他事务对该表进行写操作（可能允许读操作，取决于锁的类型）。表锁粒度大，开销小，但并发度低。
- **页锁**：在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中有多个行记录。只有BDB存储引擎支持页锁，页锁的开销介于表锁和行锁之间，并发度一般，会出现死锁。
- **全局锁**：锁住整个数据库实例，加锁后整个实例就处于只读状态，后续的DML（数据操纵语言）、DDL（数据定义语言）语句以及已经更新操作的事务提交语句都将被阻塞。通常用于做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

#### 	**按锁的功能分类**

- **共享锁（S锁）**：又称读锁，允许多个事务对同一资源加共享锁进行并发读操作，但加共享锁的事务不能修改数据。
- **排他锁（X锁）**：又称写锁，阻止其他事务对已锁定资源进行读写操作。当一个事务对某行记录加排他锁进行修改时，其他事务无法访问该行，直到排他锁释放。
- **意向锁**：又称I锁，针对表锁，主要是为了提高加表锁的效率。当有事务给表的数据行加了共享锁或排他锁时，同时会给表设置一个标识，代表已经有行锁了。其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。意向锁是隐式的，不需要用户显式加锁，它分为意向共享锁（IS锁）和意向排他锁（IX锁）。

​			在进行表锁时对表中的行进行判断是否有行锁十分必要：因为若该行有行锁那么对于加表锁的事务而言无法加锁成功-原因在于锁机制的互斥性：

> 如果一个事务已经对表中的某一行或多行加了行锁，那么当另一个事务尝试对整个表加表锁时，由于表锁会覆盖整个表（包括已被行锁锁定的行），因此这两个锁会相互冲突。
>
> 在这种情况下，数据库系统会阻止第二个事务加表锁，直到第一个事务释放所有相关的行锁。这是为了确保数据的一致性和避免潜在的并发问题。

- **间隙锁**：锁定记录间的间隙，防止其他事务在间隙中插入或删除记录，从而避免了脏读和不可重复读等问题的出现。间隙锁是在访问索引时产生的，它会锁住索引中的区间范围，而不是具体的记录。间隙锁主要解决了幻读的问题，特别是在InnoDB存储引擎的可重复读事务隔离级别下。

> 在间隙锁下，当事务对某个索引范围进行查询时由于锁住了该区间范围，这就导致了其他事务无法对该区间进行修改-即无法插入和删除在区间的记录；这避免了幻读的出现

#### **锁的实现方式分类**

- **乐观锁**：并不会真正地锁某行记录，而是通过版本号或时间戳来实现的。只有当事务提交时检查数据的一致性，才决定是否允许更新。这种方式适合并发量大、冲突较少的场景。

> ### 乐观锁的核心思想
>
> 乐观锁**假定并发冲突不是经常发生的**，因此允许多个事务或线程同时访问相同的资源。它并不在数据读取时立即加锁，而是**在数据更新时进行检查**。
>
> ### **实现方式**
>
> 1. **版本号方式**：
>    - 在数据表中增加一个版本号字段。
>    - 每次更新数据时，将版本号加1，并将当前版本号作为更新条件。
>    - 如果当前版本号与更新时的版本号一致，则更新成功；否则，更新失败。
> 2. **时间戳方式**：
>    - 在数据表中增加一个时间戳字段。
>    - 每次更新数据时，将时间戳更新为当前时间戳，并将当前时间戳作为更新条件。
>    - 如果当前时间戳与更新时的时间戳一致，则更新成功；否则，更新失败。

- **悲观锁**：行锁、表锁等都是悲观锁。悲观锁会在读取或写入数据时锁定相关的数据行或表，以防止其他事务并发修改数据，导致数据不一致。

## 四.MVVC
